name: Poc Org Deployment
on:
  push:
    branches:
      - demo  # Trigger deployment when changes are pushed to the 'demo' branch
jobs:
  deploy-lwc-and-apex:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Fetches all history for all branches and tags
          
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Install Salesforce CLI
        run: |
          npm install @salesforce/cli --global
          sf --version
          
      - name: Install dependencies
        run: |
          # Only run npm install if package.json exists
          if [ -f "package.json" ]; then
            npm install
          else
            echo "No package.json found, skipping npm install"
          fi
        
      - name: Authenticate with Salesforce
        run: |
          echo "${{ secrets.SALESFORCE_AUTH_URL }}" > ./SALESFORCE_AUTH_URL.txt
          sf org login sfdx-url -f ./SALESFORCE_AUTH_URL.txt -a targetOrg
      
      - name: Find Changed Files
        id: changed-files
        run: |
          # Get the previous commit hash
          PREV_COMMIT=$(git rev-parse HEAD~1)
          CURRENT_COMMIT=$(git rev-parse HEAD)
          echo "Comparing changes between $PREV_COMMIT and $CURRENT_COMMIT"
          
          # Create directory for changed files list
          mkdir -p ./changed_files
          
          # Find changed files in force-app/main/default/lwc
          git diff --name-only $PREV_COMMIT $CURRENT_COMMIT -- force-app/main/default/lwc > ./changed_files/lwc_changes.txt
          
          # Find changed files in force-app/main/default/classes
          git diff --name-only $PREV_COMMIT $CURRENT_COMMIT -- force-app/main/default/classes > ./changed_files/apex_changes.txt
          
          # Check if there are any changes to deploy
          HAS_LWC_CHANGES=false
          HAS_APEX_CHANGES=false
          
          if [ -s ./changed_files/lwc_changes.txt ]; then
            echo "Changed LWC files detected:"
            cat ./changed_files/lwc_changes.txt
            HAS_LWC_CHANGES=true
          else
            echo "No LWC changes detected"
          fi
          
          if [ -s ./changed_files/apex_changes.txt ]; then
            echo "Changed Apex files detected:"
            cat ./changed_files/apex_changes.txt
            HAS_APEX_CHANGES=true
          else
            echo "No Apex changes detected"
          fi
          
          if [ "$HAS_LWC_CHANGES" == "true" ] || [ "$HAS_APEX_CHANGES" == "true" ]; then
            echo "HAS_CHANGES=true" >> $GITHUB_ENV
            echo "HAS_LWC_CHANGES=$HAS_LWC_CHANGES" >> $GITHUB_ENV
            echo "HAS_APEX_CHANGES=$HAS_APEX_CHANGES" >> $GITHUB_ENV
          else
            echo "HAS_CHANGES=false" >> $GITHUB_ENV
          fi
        
      - name: Deploy Changed Components to Salesforce
        if: env.HAS_CHANGES == 'true'
        run: |
          # Create a manifest file for only changed components
          mkdir -p manifest
          echo '<?xml version="1.0" encoding="UTF-8"?>' > manifest/package.xml
          echo '<Package xmlns="http://soap.sforce.com/2006/04/metadata">' >> manifest/package.xml
          
          # Add LWC components that have changed
          if [ -s ./changed_files/lwc_changes.txt ]; then
            echo '    <types>' >> manifest/package.xml
            
            # Process each changed LWC folder
            cat ./changed_files/lwc_changes.txt | grep -o "force-app/main/default/lwc/[^/]*" | sort | uniq | while read -r LWC_PATH; do
              LWC_NAME=$(basename "$LWC_PATH")
              echo "        <members>$LWC_NAME</members>" >> manifest/package.xml
            done
            
            echo '        <name>LightningComponentBundle</name>' >> manifest/package.xml
            echo '    </types>' >> manifest/package.xml
          fi
          
          # Add Apex classes that have changed
          if [ -s ./changed_files/apex_changes.txt ]; then
            echo '    <types>' >> manifest/package.xml
            
            # Process each changed Apex class
            cat ./changed_files/apex_changes.txt | grep "\.cls$" | while read -r APEX_FILE; do
              APEX_NAME=$(basename "$APEX_FILE" .cls)
              echo "        <members>$APEX_NAME</members>" >> manifest/package.xml
            done
            
            echo '        <name>ApexClass</name>' >> manifest/package.xml
            echo '    </types>' >> manifest/package.xml
          fi
          
          echo '    <version>58.0</version>' >> manifest/package.xml
          echo '</Package>' >> manifest/package.xml
          
          echo "Created deployment manifest:"
          cat manifest/package.xml
  
          # Validate manifest before deployment
          if [ ! -s manifest/package.xml ]; then
            echo "Error: Empty or missing manifest file!"
            exit 1
          fi
          
          # Check if manifest has actual components
          if ! grep -q "<members>" manifest/package.xml; then
            echo "Error: No components found in manifest!"
            cat manifest/package.xml
            exit 1
          fi
          
          # Deploy only the changed components using the manifest
          echo "Starting deployment..."
          if sf project deploy start --ignore-conflicts -o targetOrg -l NoTestRun -x manifest/package.xml --json > deployment_result.json; then
            echo "Deployment command executed successfully"
            echo "Deployment result:"
            cat deployment_result.json
          else
            echo "Deployment command failed!"
            echo "Error output:"
            cat deployment_result.json
            exit 1
          fi
          
      - name: Check Deployment Status
        if: env.HAS_CHANGES == 'true'
        run: |
          if [ ! -f deployment_result.json ]; then
            echo "No deployment result file found!"
            exit 1
          fi
          
          # Extract deployment ID with better error handling
          DEPLOY_ID=$(cat deployment_result.json | jq -r '.result.id // empty')
          
          if [ -z "$DEPLOY_ID" ] || [ "$DEPLOY_ID" == "null" ]; then
            echo "Could not extract deployment ID from result:"
            cat deployment_result.json
            # Check if there was an error in the deployment command
            ERROR_MSG=$(cat deployment_result.json | jq -r '.message // empty')
            if [ -n "$ERROR_MSG" ]; then
              echo "Error message: $ERROR_MSG"
            fi
            exit 1
          fi
          
          echo "Deployment ID: $DEPLOY_ID"
          
          # Wait and check deployment status with timeout
          MAX_ATTEMPTS=20
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            echo "Checking deployment status (Attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS)..."
            
            if STATUS_RESULT=$(sf project deploy report -i $DEPLOY_ID -o targetOrg --json 2>&1); then
              STATUS=$(echo "$STATUS_RESULT" | jq -r '.result.status // "Unknown"')
              echo "Current deployment status: $STATUS"
              
              if [ "$STATUS" == "Succeeded" ]; then
                echo "Deployment completed successfully!"
                echo "Deployment details:"
                echo "$STATUS_RESULT" | jq '.result'
                break
              elif [ "$STATUS" == "Failed" ] || [ "$STATUS" == "Error" ]; then
                echo "Deployment failed!"
                echo "Failure details:"
                echo "$STATUS_RESULT" | jq '.result'
                
                # Show detailed error information
                echo "Detailed error information:"
                echo "$STATUS_RESULT" | jq -r '.result.details.componentFailures[]? | "Component: \(.componentType).\(.fullName) - Error: \(.problem)"'
                exit 1
              elif [ "$STATUS" == "InProgress" ] || [ "$STATUS" == "Pending" ]; then
                echo "Deployment is still in progress..."
              else
                echo "Unknown status: $STATUS"
                echo "Full response:"
                echo "$STATUS_RESULT"
              fi
            else
              echo "Failed to check deployment status:"
              echo "$STATUS_RESULT"
              exit 1
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
            
            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              echo "Waiting 30 seconds before next check..."
              sleep 30
            fi
          done
          
          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "Deployment timed out after $((MAX_ATTEMPTS * 30)) seconds"
            echo "Final status check:"
            sf project deploy report -i $DEPLOY_ID -o targetOrg --json | jq '.'
            exit 1
          fi
      
      - name: Skip Deployment Notice
        if: env.HAS_CHANGES == 'false'
        run: |
          echo "No LWC changes detected in this commit. Skipping deployment."
          
      - name: Cleanup
        if: always()
        run: |
          # Clean up sensitive files
          rm -f ./SALESFORCE_AUTH_URL.txt
          rm -f deployment_result.json
